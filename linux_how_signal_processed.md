# Linux 如何处理挂起的信号 (Pending Signals)

## 核心思想

Linux 内核在进程**从内核态（Kernel Mode）返回用户态（User Mode）的瞬间**，会检查并处理该进程的挂起（pending）信号。

## 触发信号处理的两个主要时机

1.  **系统调用（System Call）返回时**：当进程执行完一个系统调用（如 `read()`, `write()`），在内核准备将控制权交还给用户代码之前。
2.  **中断（Interrupt）或异常（Exception）处理返回时**：当硬件中断（如键盘输入、时钟中断）或异常处理结束，内核准备恢复进程在用户态的执行之前。

## 详细处理流程

1.  **信号产生（Generation）**：
    - 某个事件（如用户按 `Ctrl+C`、`kill` 命令）发生，内核在目标进程的 `task_struct` 中将其标记为 pending 状态。此时信号仅被记录，不会立即处理。

2.  **进入内核态**：
    - 进程因系统调用或中断而陷入内核态执行。

3.  **返回用户态前的检查**：
    - 内核态任务完成，在返回用户态前，内核会检查当前进程是否有待处理的信号。

4.  **准备处理信号**：
    - 如果发现有未被阻塞的 pending 信号，内核会：
        a. 在该进程的**用户态栈**上创建一个新的栈帧。
        b. 该栈帧中保存了用于恢复现场的上下文信息（寄存器状态、程序计数器等）以及信号处理函数的地址。
        c. 修改进程的程序计数器（PC），使其指向用户空间中定义的信号处理函数（Signal Handler）。

5.  **执行信号处理函数**：
    - 内核返回到用户态，但**不是返回到之前被中断的代码位置**，而是开始执行信号处理函数。

6.  **从信号处理函数返回**：
    - 信号处理函数执行完毕后，会隐式或显式地调用一个特殊的系统调用（如 `sigreturn`）。
    - 进程再次进入内核态。内核利用第 4 步中保存在用户栈上的上下文信息，将进程的寄存器和程序计数器恢复到被中断前的状态。

7.  **恢复正常执行**：
    - 内核再次返回用户态，这次是回到最初被中断的地方，进程继续执行它原来的代码。
