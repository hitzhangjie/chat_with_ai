让我详细解释一下同步信号（Synchronous Signal）和异步信号（Asynchronous Signal）的区别：

1. **同步信号（Synchronous Signal）**：
   - 由程序自身的执行直接触发
   - 与特定指令的执行直接相关
   - 在指令执行过程中立即发生
   - 常见的同步信号包括：
     - SIGSEGV（段错误）：访问非法内存地址
     - SIGFPE（浮点异常）：除以零等算术错误
     - SIGILL（非法指令）：执行了无效的机器指令
   - 这些信号不能被普通的信号处理机制捕获，因为它们在指令执行过程中就发生了
     >ps: 并不是不能，比如go runtime就捕获并处理了，只是说用户不要自行捕获并处理，而且也不建议，因为处理不当可能导致更严重问题。

2. **异步信号（Asynchronous Signal）**：
   - 由外部事件触发
   - 与程序当前执行状态无关
   - 可以在任何时候发生
   - 常见的异步信号包括：
     - SIGINT（中断信号）：通常由 Ctrl+C 触发
     - SIGTERM（终止信号）：请求程序终止
     - SIGUSR1/SIGUSR2（用户自定义信号）
   - 这些信号可以被 `signal.Notify` 捕获和处理

3. **举例说明**：
   ```go
   // 异步信号可以被捕获
   c := make(chan os.Signal, 1)
   signal.Notify(c, syscall.SIGINT) // 可以捕获 Ctrl+C
   
   // 同步信号不能被捕获
   var s *struct{ Age int }
   println(s.Age) // 触发 SIGSEGV，不能被 signal.Notify 捕获
   ```

4. **为什么会有这种区别**：
   - 同步信号表示程序执行出现了严重错误
   - 这些错误通常意味着程序处于一个不可恢复的状态
   - 允许程序处理这些信号可能会导致更多的问题
   - 操作系统选择直接终止程序，而不是给程序处理的机会

5. **实际应用中的处理方式**：
   - 对于同步信号（如 SIGSEGV）：
     - 使用 Go 的 panic/recover 机制
     - 进行防御性编程
     - 添加适当的错误检查
   - 对于异步信号（如 SIGINT）：
     - 使用 `signal.Notify` 捕获
     - 实现优雅的退出机制
     - 清理资源
     - 保存状态等

6. **Go 语言中的特殊处理**：
   - Go 运行时会将某些同步信号转换为 panic
   - 这些 panic 可以被 `recover()` 捕获
   - 这种机制提供了更好的错误处理方式
   - 允许程序在发生严重错误时有机会进行清理工作

理解同步信号和异步信号的区别对于编写健壮的程序非常重要，它帮助我们选择正确的错误处理策略。

>ps: 参考 `man 7 signal`，只有SIGKILL和SIGSTOP是不能被捕获、延迟、忽略的。
