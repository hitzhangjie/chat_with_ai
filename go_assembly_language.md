Go 语言的汇编（通常称为 **Go Assembly**）确实非常特殊。它基于 Plan 9 汇编，但由 Go 编译器进行了定制，增加了一些虚拟寄存器和特定的调用约定。

为了让你直观理解，我们先看一个简单的 Go 函数及其对应的汇编代码。

### 1. Go 函数示例

```go
// main.go
package main

func add(a, b int) int {
    return a + b
}

```

使用 `go tool compile -S main.go` 编译后，`add` 函数的汇编大致如下：

```asm
TEXT ·add(SB), $0-24
    MOVQ a+0(FP), AX    // 将第一个参数 a 放入寄存器 AX
    MOVQ b+8(FP), BX    // 将第二个参数 b 放入寄存器 BX
    ADDQ BX, AX         // AX = AX + BX
    MOVQ AX, ret+16(FP) // 将结果写入返回值位置
    RET

```

---

### 2. 声明详解：`TEXT ·add(SB), $0-24`

这是汇编函数的定义行，包含了核心元数据：

* **`TEXT`**: 指令助记符，表示这是一段代码段（Text Segment）。
* **`·add`**: 函数名。中间的点 `·` 是 Unicode 间隔符，用于分隔包名和函数名（如果是当前包，包名可省略）。
* **`(SB)`**: **Static Base**。虚拟寄存器，表示全局静态基址。所有的全局符号（函数、变量）都是相对于 SB 的偏移。
* **`$0-24`**:
* **`$0`**: **栈帧大小 (Frame Size)**。表示该函数在栈上分配的本地变量空间大小。这里是 0，因为 `add` 直接使用寄存器和参数空间，没开辟本地变量。
* **`24`**: **参数大小 (Args Size)**。Go 早期版本完全通过栈传递参数。在 64 位机器上，`int` 占 8 字节。这里两个输入参数 `a, b` (16字节) + 一个返回值 (8字节) = 24 字节。



---

### 3. 核心虚拟寄存器

Go 汇编引入了 4 个伪寄存器，理解它们是读懂代码的关键：

| 寄存器 | 全称 | 作用 |
| --- | --- | --- |
| **FP** | Frame Pointer | **参数与返回值**。指向调用者传入参数的起始位置。用法：`name+offset(FP)`。 |
| **PC** | Program Counter | **程序计数器**。用于跳转和分支。 |
| **SB** | Static Base | **全局符号**。指向程序的静态内存区。 |
| **SP** | Stack Pointer | **本地变量**。指向当前函数栈帧的顶部。 |

> **注意：** Go 汇编中的 `SP` 比较坑。如果你写 `symbol+offset(SP)`，它是伪寄存器（指向本地变量）；如果你写 `offset(SP)`，它是硬件真实寄存器（指向栈顶）。

---

### 4. 常见指令对照表

Go 汇编指令的后缀通常代表操作的数据宽度：`Q` (Quadword, 64位), `L` (Long, 32位), `W` (Word, 16位), `B` (Byte, 8位)。

| 指令 | 含义 | 示例 | 解释 |
| --- | --- | --- | --- |
| **MOVQ** | Move | `MOVQ $10, AX` | 把立即数 10 搬运到 AX 寄存器 |
| **LEAQ** | Load Effective Address | `LEAQ (AX)(BX*8), CX` | 计算地址并存入 CX (类似 `CX = AX + BX*8`) |
| **ADDQ** | Add | `ADDQ BX, AX` | `AX = AX + BX` |
| **SUBQ** | Subtract | `SUBQ $16, SP` | `SP = SP - 16` (分配栈空间) |
| **JMP** | Jump | `JMP label` | 无条件跳转到 label |
| **CALL** | Call | `CALL runtime.newobject(SB)` | 调用函数 |
| **RET** | Return | `RET` | 函数返回 |

---

### 5. 进阶：栈帧结构图示

当你看到一个更复杂的函数（比如有本地变量）时，栈帧的布局如下：

* **调用者的栈帧**：存放着传给被调用者的参数和预留的返回值空间。
* **FP (伪)**：指向调用者参数的起始。
* **SP (伪)**：指向本地变量的起始。
* **硬件 SP**：指向当前物理栈顶，用于 `PUSH/POP` 操作。

### 总结

1. **方向性**：Plan 9 汇编的数据流向是 **从左到右**。`MOVQ $1, AX` 是把 1 给 AX。
2. **符号性**：函数定义必须以 `TEXT` 开头。
3. **寄存器适配**：虽然是 Plan 9 风格，但在 x64 下，你依然可以使用 `AX, BX, CX, DX, SI, DI, R8-R15` 等物理寄存器。

